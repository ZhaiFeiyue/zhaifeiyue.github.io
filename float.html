<meta charset="utf8">
<title>Float Toy</title>
<style>
  body {
    margin: 50px;
    font: 14px/20px sans-serif;
    cursor: default;
  }

  a {
    color: inherit;
  }

  p {
    margin: 30px 0;
  }

  h2 {
    margin: 60px 0 30px 0;
  }

  table {
    border-collapse: collapse;
    font-size: 20px;
    line-height: 14px;
    width: 100%;
  }

  td {
    font: inherit;
    padding: 0;
    text-align: center;
  }

  td.sign {
    background: #BBF;
  }

  td.exponent {
    background: #BFB;
  }

  td.fraction {
    background: #FBB;
  }

  td.sign.hover {
    background: #99D;
  }

  td.exponent.hover {
    background: #9D9;
  }

  td.fraction.hover {
    background: #D99;
  }

  .input td {
    border: 1px solid #000;
    padding: 5px 2px;
    font-size: 14px;
  }

  .zerox-col {
    vertical-align: bottom;
  }

  .zerox {
    height: 26px;
    line-height: 26px;
  }

  .output-col {
    width: 100%;
    vertical-align: bottom;
  }

  .hex-col {
    width: 100%;
  }

  .output {
    font: inherit;
    padding: 5px;
    margin: -5px;
    border: 0;
    outline: none;
    width: 100%;
    min-width: 200px;
    background: none;
    height: 26px;
    line-height: 26px;
    box-sizing: content-box;
  }

  .output:hover,
  .output:focus {
    background: rgba(0, 0, 0, 0.066);
  }

  .help {
    height: 50px;
    font-size: 20px;
    line-height: 60px;
    padding-left: 3px;
    white-space: nowrap;
  }

  .help sup {
    vertical-align: top;
    font-size: 12px;
    line-height: 50px;
  }

  .help span {
    padding: 3px;
    margin: -3px;
  }

  td.nibble {
    font-size: 10px;
    line-height: 6px;
    border: none;
  }

  td.dark.nibble {
    background: #DDD;
  }

  span.sign {
    background: #DDF;
  }

  span.exponent {
    background: #DFD;
  }

  span.fraction {
    background: #FDD;
  }
</style>

<body>
  <h1>Float Toy</h1>
  <p>
    Click on a cell below to toggle bit values, or edit the hex or decimal values directly.
    Use this to build intuition for the IEEE floating-point format.
    See Wikipedia for details on the <a
      href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">half-precision</a>, <a
      href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">single-precision</a> and <a
      href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">double-precision</a> floating-point
    formats.
  </p>

  <h2>8-bit (E4M3)</h2>
  <table>
    <tr>
      <td><span id="inpute4m3" class="input"></span></td>
      <td class="zerox-col"><span class="zerox">&nbsp;&nbsp;=&nbsp;&nbsp;0x</span></td>
      <td class="output-col"><input id="hexe4m3" class="output"></td>
    </tr>
  </table>
  <table>
    <tr>
      <td><span id="helpe4m3" class="help"></span></td>
      <td>&nbsp;&nbsp;=&nbsp;&nbsp;</td>
      <td class="hex-col"><input id="outpute4m3" class="output"></td>
    </tr>
  </table>

  <h2>8-bit (E5M2)</h2>
  <table>
    <tr>
      <td><span id="inpute5m2" class="input"></span></td>
      <td class="zerox-col"><span class="zerox">&nbsp;&nbsp;=&nbsp;&nbsp;0x</span></td>
      <td class="output-col"><input id="hexe5m2" class="output"></td>
    </tr>
  </table>
  <table>
    <tr>
      <td><span id="helpe5m2" class="help"></span></td>
      <td>&nbsp;&nbsp;=&nbsp;&nbsp;</td>
      <td class="hex-col"><input id="outpute5m2" class="output"></td>
    </tr>
  </table>

  <h2>16-bit (half)</h2>
  <table>
    <tr>
      <td><span id="input16" class="input"></span></td>
      <td class="zerox-col"><span class="zerox">&nbsp;&nbsp;=&nbsp;&nbsp;0x</span></td>
      <td class="output-col"><input id="hex16" class="output"></td>
    </tr>
  </table>
  <table>
    <tr>
      <td><span id="help16" class="help"></span></td>
      <td>&nbsp;&nbsp;=&nbsp;&nbsp;</td>
      <td class="hex-col"><input id="output16" class="output"></td>
    </tr>
  </table>

  <h2>16-bit (bf16)</h2>
  <table>
    <tr>
      <td><span id="inputbf16" class="input"></span></td>
      <td class="zerox-col"><span class="zerox">&nbsp;&nbsp;=&nbsp;&nbsp;0x</span></td>
      <td class="output-col"><input id="hexbf16" class="output"></td>
    </tr>
  </table>
  <table>
    <tr>
      <td><span id="helpbf16" class="help"></span></td>
      <td>&nbsp;&nbsp;=&nbsp;&nbsp;</td>
      <td class="hex-col"><input id="outputbf16" class="output"></td>
    </tr>
  </table>

  <h2>32-bit (TF32)</h2>
  <table>
    <tr>
      <td><span id="inputtf32" class="input"></span></td>
      <td class="zerox-col"><span class="zerox">&nbsp;&nbsp;=&nbsp;&nbsp;0x</span></td>
      <td class="output-col"><input id="hextf32" class="output"></td>
    </tr>
  </table>
  <table>
    <tr>
      <td><span id="helptf32" class="help"></span></td>
      <td>&nbsp;&nbsp;=&nbsp;&nbsp;</td>
      <td class="hex-col"><input id="outputtf32" class="output"></td>
    </tr>
  </table>

  <h2>AMD FP24</h2>
  <table>
    <tr>
      <td><span id="inputfp24" class="input"></span></td>
      <td class="zerox-col"><span class="zerox">&nbsp;&nbsp;=&nbsp;&nbsp;0x</span></td>
      <td class="output-col"><input id="hexfp24" class="output"></td>
    </tr>
  </table>
  <table>
    <tr>
      <td><span id="helpfp24" class="help"></span></td>
      <td>&nbsp;&nbsp;=&nbsp;&nbsp;</td>
      <td class="hex-col"><input id="outputfp24" class="output"></td>
    </tr>
  </table>


  <h2>32-bit (float)</h2>
  <table>
    <tr>
      <td><span id="input32" class="input"></span></td>
      <td class="zerox-col"><span class="zerox">&nbsp;&nbsp;=&nbsp;&nbsp;0x</span></td>
      <td class="output-col"><input id="hex32" class="output"></td>
    </tr>
  </table>
  <table>
    <tr>
      <td><span id="help32" class="help"></span></td>
      <td>&nbsp;&nbsp;=&nbsp;&nbsp;</td>
      <td class="hex-col"><input id="output32" class="output"></td>
    </tr>
  </table>

  <h2>64-bit (double)</h2>
  <table>
    <tr>
      <td><span id="input64" class="input"></span></td>
      <td class="zerox-col"><span class="zerox">&nbsp;&nbsp;=&nbsp;&nbsp;0x</span></td>
      <td class="output-col"><input id="hex64" class="output"></td>
    </tr>
  </table>
  <table>
    <tr>
      <td><span id="help64" class="help"></span></td>
      <td>&nbsp;&nbsp;=&nbsp;&nbsp;</td>
      <td class="hex-col"><input id="output64" class="output"></td>
    </tr>
  </table>
</body>
<script src="./float16.js"></script>
<script>
  const { Float16Array } = float16;

  function float64ToBits(doubleNumber) {
    // Check if the input is a valid number
    if (typeof doubleNumber !== "number")
      throw new Error("A float number is expected.");

    // Create an 8-byte ArrayBuffer to store the double
    var buffer = new ArrayBuffer(8);
    // Create a Float64Array view on the buffer and store the double number
    (new Float64Array(buffer))[0] = doubleNumber;
    // Create a Uint32Array view on the buffer to access the bits as integers
    var uint32Array = new Uint32Array(buffer);

    // Combine the two 32-bit integers into a 64-bit binary string
    let binaryString = "";
    for (let i = 1; i >= 0; --i) {
      var bits = uint32Array[i].toString(2).padStart(32, "0");
      binaryString += bits;
    }

    // Extract the sign bit, exponent, and mantissa
    var signBit = binaryString.substring(0, 1);
    var exponentBits = binaryString.substring(1, 12);
    var mantissaBits = binaryString.substring(12, 64);

    // Return the sign, exponent, and mantissa as an array
    return [signBit, exponentBits, mantissaBits];
  }

  class FloatArray {
    constructor(init, num_sign = 1, num_e = 5, num_m = 10, custom_func = []) {
      this.num_s = num_sign;
      this.num_e = num_e;
      this.num_m = num_m;
      this.num_bits = num_sign + num_e + num_m;
      this.Bits = new Uint8Array(this.num_bits);
      for (var i = 0; i < this.Bits.length; i++) {
        this.Bits[i] = 0;
      }
      this.custom_func = custom_func;

      this.fromFloat(init);
    }

    click(index) {
      if (this.Bits[index] == 1) {
        this.Bits[index] = 0;
      } else {
        this.Bits[index] = 1;
      }
    }

    getE() {
      var exponent = 0;
      if (this.isExponentAllZero()) {
        exponent = 1;
      }

      for (var i = 0; i < this.num_e; i++) {
        var index = 1 + i;
        var bit = this.Bits[index];
        exponent += bit << (this.num_e - i - 1);
      }
      var exponentBias = (1 << (this.num_e - 1)) - 1;
      exponent -= exponentBias;
      return exponent;
    }

    getS() {
      return (this.Bits[0] ? -1 : 1);
    }

    isExponentAllZero() {
      var sum = 0;
      for (var i = this.num_s; i < this.num_e + this.num_s; i++) {
        sum += this.Bits[i];
      }

      return sum == 0;
    }

    getF() {
      var base = 1.0;
      if (this.isExponentAllZero()) {
        base = 0.0;
      }

      var offset = this.num_s + this.num_e;
      for (var i = offset; i < this.num_bits; i++) {
        base += this.Bits[i] * 2 ** (offset - i - 1);
      }
      return base;
    }

    getFloat() {
      for (var i = 0; i < this.custom_func.length; i++) {
        var tmp = this.custom_func[i](this.num_s, this.num_e, this.num_m, this.Bits);
        if (tmp != null) {
          return tmp;
        }
      }
      var fraction = this.getF();
      var float_output = this.getS() * fraction * 2 ** this.getE();
      return float_output.toPrecision(Math.ceil(Math.log10(2 ** (this.num_m + 1))));
    }

    fromHex(hexstr) {
      for (var i = 0; i < hexstr.length; i++) {
        var binstr = parseInt(hexstr[i], 16).toString(2).padStart(4, '0');
        for (var j = 0; j < binstr.length; j++) {
          this.Bits[i * 4 + j] = parseInt(binstr[j], 2);
        }
      }
    }

    fromFloat(f) {
      // f should be represented by float64
      var out = float64ToBits(f);
      this.Bits[0] = parseInt(out[0], 2);

      for (var i = 0; i < this.num_m; i++) {
        this.Bits[this.num_s + this.num_e + i] = parseInt(out[2][i], 2);
      }

      if (out[1] == "00000000000") {
        for (var i = 0; i < this.num_e; i++) {
          this.Bits[this.num_s + i] = 0;
        }
        return;
      }

      var newExponentBias = (1 << (this.num_e - 1)) - 1;
      var oldExponentBias = (1 << (11 - 1)) - 1;
      var exponent = 0;

      for (var i = 0; i < out[1].length; i++) {
        var bit = parseInt(out[1][i], 2);
        exponent += bit << (11 - i - 1);
      }

      var new_e = newExponentBias + exponent - oldExponentBias;
      var binary = new_e.toString(2).padStart(this.num_e, '0');
      for (var i = 0; i < binary.length; i++) {
        this.Bits[this.num_s + i] = parseInt(binary[i], 2);
      }
    }

    toHex() {
      var d = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
      var output = '';
      var tmp = 0;
      for (var i = 0; i < this.Bits.length; i++) {
        tmp += this.Bits[i] << 3 - (i % 4);
        if ((i + 1) % 4 == 0) {
          output += d[tmp];
          tmp = 0;
        }
      }
      if (this.Bits.length % 4 == 0) {
        return output;
      } else {
        return output + d[tmp];
      }

    }

    getHexLength() {
      return (this.Bits.length - 1) / 4 + 1;
    }
  }

  (function () {

    function load(array, input, output, help, hex) {
      // Populate HTML
      var html = '<table>';
      // The bit numbers
      html += '<tr>';
      for (var i = 0; i < array.num_bits; i++) {
        var index = array.num_bits - i - 1;
        if (index % 2 == 0) {
          html += '<td class="nibble">' + index + '</td>'
        } else {
          html += '<td class="dark nibble">' + index + '</td>'
        }
      }
      html += '</tr>';
      // The bits
      html += '<tr>';
      for (var i = 0; i < array.num_bits; i++) {
        var className =
          i === 0 ? 'sign' :
            i < 1 + array.num_e ? 'exponent' :
              'fraction';
        html += '<td data-index="' + i + '" class="' + className + '">0</td>';
      }
      html += '</tr></table>';
      input.innerHTML = html;

      // Grab elements
      var elements = [];
      for (var i = 0; i < array.num_bits; i++) {
        (function (i) {
          var element = input.querySelector('[data-index="' + i + '"]');
          element.onmouseover = function () { this.classList.add('hover'); };
          element.onmouseout = function () { this.classList.remove('hover'); };
          elements.push(element);
        })(i);
      }

      // Event handlers
      function extractNumber() {
        return +(output.value.replace(/\b(?:infinity|inf|Inf)\b/gi, 'Infinity'));
      }
      output.onkeydown = function (e) {
        if (e.which === 13) {
          e.preventDefault();
          output.blur();
        }
      };
      output.oninput = function () {
        array.fromFloat(extractNumber())
        render();
      };
      output.onblur = function () {
        render();
      };

      hex.onkeydown = function (e) {
        if (e.which === 13) {
          e.preventDefault();
          hex.blur();
        }
      };
      hex.onfocus = function () {
        hex.select();
      };
      hex.oninput = function () {
        var hexAlphabet = '0123456789abcdefABCDEF';
        var validHexCharas = hex.value.split('').every(function (c) {
          return hexAlphabet.split('').lastIndexOf(c) !== -1;
        });
        var hexLength = array.getHexLength();
        if (hex.value.length > hexLength || validHexCharas === false) {
          hex.value = hex.value.slice(0, -1);
        }
        array.fromHex(hex.value);
        render();
      };
      hex.onblur = function () {
        render();
      };

      input.onmousedown = function (e) {
        if ('index' in e.target.dataset) {
          var index = e.target.dataset.index | 0;
          array.click(index);
          render();

          document.onmouseup = function () {
            document.onmousemove = null;
            document.onmouseup = null;
          };
        }
      };

      // Update loop
      function render() {
        for (var i = 0; i < array.num_bits; i++) {
          elements[i].textContent = array.Bits[i];
        }

        // Update views according to which input was edited
        if (document.activeElement === hex) {
          hex.value = array.toHex();
          output.value = array.getFloat();
        } else if (document.activeElement === output) {
          output.value = array.getFloat();
          hex.value = array.toHex();
        } else {
          output.value = array.getFloat();
          hex.value = array.toHex();
        }

        help.innerHTML =
          '<span class="sign">' + array.getS() + '</span>' +
          '&nbsp;&nbsp;&times;&nbsp;&nbsp;' +
          '<span class="exponent">2<sup>' + array.getE() + '</sup></span>' +
          '&nbsp;&nbsp;&times;&nbsp;&nbsp;' +
          '<span class="fraction">' + array.getF().toPrecision(Math.ceil(Math.log10(2 ** (array.num_m + 1)))) + '</span>';
      }

      render();
    }

    function check_e4m3_nan(s, e, m, input_array) {
      var sum = 0;
      for (var i = s; i < input_array.length; i++) {
        sum += input_array[i];
      }

      var out = input_array[0] ? "-" : "";
      if (sum != 7) {
        return null;
      }

      return out + "NaN";
    }

    function check_flaot16_zero(s, e, m, input_array) {
      var sum = 0;
      for (var i = s; i < input_array.length; i++) {
        sum += input_array[i];
      }
      var out = input_array[0] ? "-" : "";
      if (sum == 0) {
        return out + "0";
      }
      return null;
    }

    function check_float16_inf(s, e, m, input_array) {
      for (var i = s + e; i < input_array.length; i++) {
        if (input_array[i] != 0) {
          return null;
        }
      }

      for (var i = s; i < input_array.length - m; i++) {
        if (input_array[i] != 1) {
          return null;
        }
      }

      var out = input_array[0] ? "-" : "";
      return out + "Inf";
    }

    function check_float16_nan(s, e, m, input_array) {
      for (var i = s; i < input_array.length - m; i++) {
        if (input_array[i] != 1) {
          return null;
        }
      }

      var sum = 0;
      for (var i = s + e; i < input_array.length; i++) {
        sum += input_array[i];
      }

      var out = input_array[0] ? "-" : "";
      if (sum == 0) {
        return null;
      }

      return out + "NaN";
    }

    load(new FloatArray(Math.PI, 1, 4, 3, [check_e4m3_nan, check_flaot16_zero]), document.getElementById('inpute4m3'), document.getElementById('outpute4m3'), document.getElementById('helpe4m3'), document.getElementById('hexe4m3'));
    load(new FloatArray(Math.PI, 1, 5, 2, [check_float16_nan, check_float16_inf, check_flaot16_zero]), document.getElementById('inpute5m2'), document.getElementById('outpute5m2'), document.getElementById('helpe5m2'), document.getElementById('hexe5m2'));
    load(new FloatArray(Math.PI, 1, 5, 10, [check_float16_nan, check_float16_inf, check_flaot16_zero]), document.getElementById('input16'), document.getElementById('output16'), document.getElementById('help16'), document.getElementById('hex16'));
    load(new FloatArray(Math.PI, 1, 8, 7, [check_float16_nan, check_float16_inf, check_flaot16_zero]), document.getElementById('inputbf16'), document.getElementById('outputbf16'), document.getElementById('helpbf16'), document.getElementById('hexbf16'));
    load(new FloatArray(Math.PI, 1, 8, 10, [check_float16_nan, check_float16_inf, check_flaot16_zero]), document.getElementById('inputtf32'), document.getElementById('outputtf32'), document.getElementById('helptf32'), document.getElementById('hextf32'), 10);
    load(new FloatArray(Math.PI, 1, 7, 16, [check_float16_nan, check_float16_inf, check_flaot16_zero]), document.getElementById('inputfp24'), document.getElementById('outputfp24'), document.getElementById('helpfp24'), document.getElementById('hexfp24'), 23);
    load(new FloatArray(Math.PI, 1, 8, 23, [check_float16_nan, check_float16_inf, check_flaot16_zero]), document.getElementById('input32'), document.getElementById('output32'), document.getElementById('help32'), document.getElementById('hex32'), 23);
    load(new FloatArray(Math.PI, 1, 11, 52, [check_float16_nan, check_float16_inf, check_flaot16_zero]), document.getElementById('input64'), document.getElementById('output64'), document.getElementById('help64'), document.getElementById('hex64'), 52);

  })();

</script>